#!/usr/bin/env ruby
require 'rubygems'
require 'libxml'


class UdonChild
  attr_accessor :child_type
end

class UdonElement < UdonChild
  attr_accessor :name, :id, :unaries, :attributes, :children
  def initialize(args={})
    @child_type = :element
    @name =       args.delete(:name)
    @id =         args.delete(:id)
    @unaries =    args.delete(:unaries)
    @attributes = args.delete(:attributes)
    @children =   args.delete(:children)
  end
end

# Node starts
#   (for now, skip if not normal)
#   increment depth
#   
include LibXML

class UdonConstructor
  attr_accessor :children
  def initialize
    @children = []
    @cstack = []
  end

  # Called for a CDATA block event.
  def on_cdata_block(cdata)
    STDOUT << "on_cdata_block" << "\n" <<
              "  cdata " << cdata << "\n"
    STDOUT.flush
  end

  # Called for a characters event.
  def on_characters(chars)
    STDOUT << "on_characters" << "\n" <<
              "  chars " << chars << "\n" 
    STDOUT.flush
  end

  # Called for a comment event.
  def on_comment(comment)
    STDOUT << "on_comment" << "\n" <<
              "  comment: " << comment << "\n"
    STDOUT.flush
  end

  # Called for a end document event.
  def on_end_document
    STDOUT << "on_end_document\n"
    STDOUT.flush
  end

  # Called for a end element event.
  def on_end_element_ns(name, prefix, uri)
    STDOUT << "on_end_element_ns" << "\n" <<
              "  name: " << name << "\n" <<
              "  prefix: " << prefix << "\n" <<
              "  uri: " << uri << "\n"
    STDOUT.flush
  end

  # Called for parser errors.
  def on_error(error)
    STDOUT << "on_error" << "\n"
              "  error " << error << "\n"
    STDOUT.flush
  end

  # Called for an external subset event.
  def on_external_subset(name, external_id, system_id) end

  # Called for an external subset notification event.
  def on_has_external_subset
    STDOUT << "on_has_internal_subset\n"
    STDOUT.flush
  end

  # Called for an internal subset notification event.
  def on_has_internal_subset
    STDOUT << "on_has_internal_subset\n"
    STDOUT.flush
  end

  # Called for an internal subset event.
  def on_internal_subset(name, external_id, system_id) end

  # Called for 'is standalone' event.
  def on_is_standalone
    STDOUT << "on_is_standalone\n"
    STDOUT.flush
  end

  # Called for an processing instruction event.
  def on_processing_instruction(target, data)
    STDOUT << "on_characters" << "\n"
              "  target: " << target << "\n" <<
              "  data:   " << data << "\n"
    STDOUT.flush
  end

  # Called for a reference event.
  def on_reference(name)
    STDOUT << "on_reference:" << "\n" <<
              "  name:" << name << "\n"
    STDOUT.flush
  end

  # Called for a start document event.
  def on_start_document
    STDOUT << "on_start_document\n"
    STDOUT.flush
  end

  # Called for a start element event.
  def on_start_element_ns(name, attributes, prefix, uri, namespaces)
    fullname = (prefix=='' ? '' : prefix+':')+name
    if (namespaces || Hash.new).count > 0
      namespaces.each do |k,v|
        if k.nil? then attributes['xmlns'] = v
        else attributes['xmlns:'+k] = v end
      end
    end
    @cstack << UdonElement.new(:name=>fullname,:attributes=>attributes)
    STDOUT << "on_start_element_ns" << "\n" <<
              "  name: " << name << "\n" <<
              "  attr: " << (attributes || Hash.new).inspect << "\n" <<
              "  prefix: " << prefix << "\n" <<
              "  uri: " << uri << "\n" <<
              "  ns_defs: " << (namespaces || Hash.new).inspect << "\n"
    STDOUT.flush
  end
end

class Xml2Udon

  MISC = {
    XML::Reader::LOADDTD => :loaddtd,
    XML::Reader::DEFAULTATTRS => :defaultattrs,
    XML::Reader::VALIDATE => :validate,
    XML::Reader::SUBST_ENTITIES => :subst_entities,
    XML::Reader::SEVERITY_VALIDITY_WARNING => :severity_validity_warning,
    XML::Reader::SEVERITY_VALIDITY_ERROR => :severity_validity_error,
    XML::Reader::SEVERITY_WARNING => :severity_warning,
    XML::Reader::SEVERITY_ERROR => :severity_error}

  TYPES = {
    XML::Reader::TYPE_NONE => :none,
    XML::Reader::TYPE_ELEMENT => :element,
    XML::Reader::TYPE_ATTRIBUTE => :attribute,
    XML::Reader::TYPE_TEXT => :text,
    XML::Reader::TYPE_CDATA => :cdata,
    XML::Reader::TYPE_ENTITY_REFERENCE => :entity_reference,
    XML::Reader::TYPE_ENTITY => :entity,
    XML::Reader::TYPE_PROCESSING_INSTRUCTION => :processing_instruction,
    XML::Reader::TYPE_COMMENT => :comment,
    XML::Reader::TYPE_DOCUMENT => :document,
    XML::Reader::TYPE_DOCUMENT_TYPE => :document_type,
    XML::Reader::TYPE_DOCUMENT_FRAGMENT => :document_fragment,
    XML::Reader::TYPE_NOTATION => :notation,
    XML::Reader::TYPE_WHITESPACE => :whitespace,
    XML::Reader::TYPE_SIGNIFICANT_WHITESPACE => :significant_whitespace,
    XML::Reader::TYPE_END_ELEMENT => :end_element,
    XML::Reader::TYPE_END_ENTITY => :end_entity,
    XML::Reader::TYPE_XML_DECLARATION => :xml_declaration}

  MODES = {
    XML::Reader::MODE_INITIAL => :mode_initial,
    XML::Reader::MODE_INTERACTIVE => :mode_interactive,
    XML::Reader::MODE_ERROR => :mode_error,
    XML::Reader::MODE_EOF => :mode_eof,
    XML::Reader::MODE_CLOSED => :mode_closed,
    XML::Reader::MODE_READING => :mode_reading }

  def io(stream)
    xml = XML::Reader.io(stream)
    while xml.read
      case xml.node_type
      when XML::Reader::TYPE_ELEMENT

        print "\n#{'  '*xml.depth}|#{xml.name}"
        attrs = (0..xml.attribute_count-1).inject({}) do |hash,v|
          xml.move_to_next_attribute
          hash[xml.name] = xml.value
          hash
        end
      end
      print " [#{TYPES[xml.node_type]}]"
    end
  end

  def saxio(stream)
    xml = XML::SaxParser.io(stream)
    xml.callbacks = UdonConstructor.new
    xml.parse
  end
end

x = Xml2Udon.new
x.saxio(ARGF)
