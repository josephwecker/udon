#!/usr/bin/env ruby
require 'pp'
require 'erb'
require 'optparse'

LANGUAGES = [:ruby]
BANNER = "Usage: genmachine [options] STATE_TABLE_FILES"

class String
  def underscore
    self.gsub(/::/, '/').
    gsub(/([A-Z]+)([A-Z][a-z])/,'\1_\2').
    gsub(/([a-z\d])([A-Z])/,'\1_\2').
    gsub(/[^a-zA-Z_]/,'_').
    downcase
  end

  def utf8_chars
    self.unpack("U*")
  end
end

class CharSet
  attr_accessor :kind
  def initialize(kind = :include)
    @kind = kind
    @include_intervals = []
    @include_any = false
  end

  def inspect
    look_for.inspect
  end

  def [](k)
    look_for[k]
  end

  def look_for
    if @include_any
      return {:kind=>@kind, :ranges=>[:any]}
    else
      ivals = @include_intervals.map do |a,b|
        a == b ? a : [a,b]
      end
      return {:kind=>@kind, :ranges=>ivals}
    end
  end

  def +(val) self.send(:<<,val) end
  def <<(val)
    if val.is_a?(String) && val =~ /([^-])-([^-])/
        include_range($1,$2)
    elsif val.is_a?(Range)
      include_range(val.first, val.last)
    elsif val == :any
      @include_any = true
    else include_char(val) end
  end

  def include_char(char) include_range(char,char) end

  def include_range(from, to)
    from = from.utf8_chars[0] if from.is_a?(String)
    to = to.utf8_chars[0] if to.is_a?(String)
    @include_intervals << [from,to].sort
    if @include_intervals.length > 1
      @include_intervals.sort!
      merged = []
      curr_a, curr_b = @include_intervals.shift
      @include_intervals.each_with_index do |ab,i|
        a,b = ab
        if a <= (curr_b+1)
          curr_b = [curr_b,b].max
        else
          merged << [curr_a, curr_b]
          curr_a,curr_b = ab
        end
      end
      merged << [curr_a, curr_b]
      @include_intervals = merged
    end
  end
end

class GenMachine
  def initialize(files)
    @table = []
    #@last_state = nil
    #@first_state = 'nil'
    @files = files
    @libraries = {}
    @executables = {}
    template_base = File.expand_path(File.dirname(__FILE__))+'/templates/'
    LANGUAGES.each do |lang|
      tbase = template_base + lang.to_s + '/'
      @libraries[lang] = ERB.new(IO.read(tbase+'library.erb.rb'),nil,'-')
      @executables[lang] = ERB.new(IO.read(tbase+'executable.erb'),nil,'-')
    end
  end

  def build
    c_name = c_args = c_cmds = c_first_state = c_states = nil
    new_fun = false
    @files.each do |fname|
      File.new(fname,'r').each_with_index do |line, line_no|
        line = line.strip
        det = line[0..0]
        if det == '|' or det == ':'
          re = (det=='|' ? '\|' : det) + '(?: |$)'
          cols = line.split(/#{re}/,-1)[1..-1].map{|c| c.strip}
          if det=='|' && cols[0].include?('(')
            new_fun = true
            unless c_name.nil?
              @table << [c_name, c_args, c_cmds, c_first_state, process_states(c_states)]
            end
            parts = cols[0].split('(')
            c_name = parts.shift.underscore
            c_args = parts.join('(').sub(/\)$/,'').split(',')
            c_states = []
            c_cmds = (cols[3]||'').split(';')
            c_first_state = cols[4]
            # TODO: error if cols[1] or cols[2] have anything
          elsif det == ':' && new_fun
            c_args += cols[0].sub(/\)$/,'').split(',')
            c_cmds += (cols[3]||'').split(';')
            c_first_state += (cols[4]||'')
          elsif det == '|'
            new_fun = false
            conditionals, inputs = parse_input(cols[1])
            c_states << {:name  => cols[0],
                         :input => inputs,
                         :cond  => conditionals,
                         :acc   => cols[2],
                         :exprs => (cols[3]||'').split(';'),
                         :next  => cols[4]}
          elsif det == ':' && (c_states.size > 0)
            conditionals, inputs = parse_input(cols[1],c_states[-1][:input])
            c_states[-1][:name] += (cols[0]||'')
            c_states[-1][:input] = inputs
            c_states[-1][:cond] += conditionals
            c_states[-1][:acc]  += cols[2]
            c_states[-1][:exprs]+= (cols[3]||'').split(';')
            c_states[-1][:next] += cols[4]
          end
        end
      end
      unless c_name.nil?
        @table << [c_name, c_args, c_cmds, c_first_state, process_states(c_states)]
      end
    end
    pp @table
  end

  def generate_class(classname, fname, language)
    @classname = classname
    f = File.new(fname, 'w+')
    f.write(@libraries[language].result(binding))
    f.close
  end

  def generate_executable(executablename, language)
    f = File.new(executablename, 'w+')
    f.write(@executables[language].result(binding))
    f.chmod(0755)
    f.close
  end

  private

  def parse_statename(val)
    if val.start_with? '>'
      state = '__'+val[1..-1].strip.underscore
      @first_state ||= state
    else
      state = '__'+val.underscore
    end
    return state
  end

  def accumulates?(states)
    states.each do |name,clauses|
      clauses.each do |c|
        c[:exprs].each do |e|
          return true if e =~ /<<s($|[^a-zA-Z0-9_])/
        end
      end
    end
    return false
  end

  def accumulators(states)
    accs = {}
    states.each do |name,clauses|
      clauses.each do |c|
        exprs = c[:exprs].dup
        exprs << c[:acc].dup
        exprs.each do |e|
          if e =~ /^([a-zA-Z_][a-zA-Z0-9_]*)?\s*<<\s*(<?)([a-zA-Z_][a-zA-Z0-9_]*)?$/
            accs[$1]=true unless ($1.nil? or $1 == '' or $1 == 'p' or $1 == 's')
            accs[$3]=true unless ($3.nil? or $3 == '' or $3 == 'p' or $3 == 's')
          end
        end
      end
    end
    return accs.keys
  end

  def makes_calls?(states)
    # TODO: implement
    false
  end

  def eof_state?(states)
    states.each{|name,clauses| return true if name=='{eof}'}
    return false
  end

  def eof_clause?(clauses)
    clauses.each{|c| return true if c[:cond].include?('eof')}
    return false
  end

  def rb_conditional(clause,states,clauses)
    has_eof_state = eof_state?(states) || eof_clause?(clauses)
    out = ''
    if clause[:cond].size > 0
      out += '('+clause[:cond].join(' || ')+')'
      out += "&& (#{rb_charset_cond(clause[:input],has_eof_state)})" unless clause[:input].nil?
    else
      out += rb_charset_cond(clause[:input],has_eof_state,',')
    end
    return rb_vars(out)
  end

  def rb_charset_cond(input,has_eof_state,sep='||')
    return 'true' if input.nil?
    outs = []
    sep = '||' if input[:kind] == :exclude
    input[:ranges].each do |range|
      if input[:kind] == :include
        if range.is_a? Array
          outs << "nl?" if (range[0] <= 0x0a) && (range[1] >= 0x0a)
          outs << "space?" if (range[0] <= 0x20) && (range[1] >= 0x20)
          outs << "(c>#{range[0]-1}&&c<#{range[1]+1})"
        else
          outs << case range
                  when 0x0a; 'nl?'
                  when 0x20; 'space?'
                  when :any; has_eof_state ? 'true' : 'c!=:eof'
                  else "c==#{range}" end
        end
      end
    end
    out = outs.join(sep)
    out = '!('+out+')' if input[:kind] == :exclude
    return out
  end

  def rb_commands(clause,currstate)
    cmds = []
    cmds += rb_simple_acc_commands(clause[:acc])
    clause[:exprs].each do |expr|
      if expr.include? '<<'
        cmds += rb_acc_commands(expr)
      else
        cmds << rb_vars(expr.strip)
      end
    end
    cmds += rb_transition_commands(clause[:next],currstate)
    return cmds.join('; ')
  end

  def rb_transition_commands(st,currstate)
    st = st.strip.split(';').map{|s|s.strip}
    out = []
    add_next = false
    st.each do |s|
      case
      when s =~ /^([^\(\[]+)(?:\[([^\]]*)\])?\(([^\)]*)\)$/   # Call another group
        funname = $1
        rename = $2
        params = $3.split(',').map{|p|rb_vars(p)}
        params << 's'
        params << "'#{rename}'" unless (rename.nil? or rename.strip=='')
        out << "state=#{funname}(#{params.join(',')})"
        add_next = true
      when s =~ /^<done>$/
        out << "return(s)"
        add_next = false
      when s =~ /^<([^>]+)>$/
        out << "return(#{rb_vars($1)})"
        add_next = false
      when s =~ /^(:[a-zA-Z0-9_:-]+)$/
        out << "state='#{$1}'" unless currstate == $1
        add_next = true
      else
        out << s
      end
    end
    out << 'next' if add_next
    return out
  end

  def rb_vars(str)
    str.tr('$','@').gsub /(:[a-zA-Z0-9_:-]+)/, '\'\1\''
  end

  def rb_simple_acc_commands(acc_phrase)
    case
    when (acc_phrase.nil? or acc_phrase == ''); return ['@fwd=true']
    when acc_phrase.strip == '<<'; return []
    when acc_phrase.strip =~ /^([a-zA-Z_][a-zA-Z0-9_]*)\s*<<\s*$/
      return ["#{rb_vars(acc_phrase.strip)}c"]
    else raise("Can't figure out your accumulator statement: #{acc_phrase}")
    end
  end

  def rb_acc_commands(acc_phrase)
    case
    when (acc_phrase.nil? or acc_phrase == ''); return ['@fwd=true']
    when acc_phrase.strip == '<<'; return []
    when acc_phrase.strip =~ /^([a-zA-Z_][a-zA-Z0-9_]*)\s*<<\s*(<?)([a-zA-Z_][a-zA-Z0-9_]*)$/
      into = $1
      value = $3
      clear_it = $2 == '<'
      into = rb_vars(into)
      value = rb_vars(value)
      if clear_it
        out = ["(#{into}<<#{value} if #{value}.size>0)"]
        out << "#{value}=''"
      else
        out = ["#{into}<<#{value}"]
      end
      return out
    else raise("Can't figure out your accumulator statement: #{acc_phrase}")
    end
  end

  # consolidate same-name states and (eventually) combine / optimize where
  # appropriate.
  def process_states(instates)
    outstates = {}
    instates.each do |inst|
      name = inst.delete(:name)
      outstates[name] ||= []
      outstates[name] << inst
    end
    return outstates
  end

  def parse_input(val,inputs=nil)
    iters = 0
    conds = []
    while val.strip.length > 0 && iters < 100
      case
      when val =~ /--+/um
        val.sub!($&,'')
      when val =~ /\s*\{([^\}]+)\}\s*/um
        conds << $1
        val.sub!($&, '')
      when val =~ /\s*\[\^([^\]]+)\]\s*/um
        inputs ||= CharSet.new(:exclude)
        parse_combine_ranges($1, inputs)
        val.sub!($&, '')
      when val =~ /\s*\[([^\]]+)\]\s*/um
        inputs ||= CharSet.new(:include)
        parse_combine_ranges($1, inputs)
        val.sub!($&, '')
      when val =~ /^\s*\./um
        inputs ||= CharSet.new(:include)
        inputs << :any
        val.sub!($&, '')
      end
      iters += 1
    end
    return conds, inputs
  end

  ESCAPES = {'\t' => "\t", '\n' => "\n",
             '\r' => "\r", '\f' => "\f",
             '\b' => "\b", '\a' => "\a",
             '\e' => "\e", '\s' => " ",
             '\[' => '[',  '\]' => ']'}
  def parse_combine_ranges(raw, input)
    raw.gsub!(/\\[tnrfbaes\[\]]/){|m| ESCAPES[m]}
    if raw =~ /((?:.-.)*)((?:.)*)/um
      ranges = $1
      singles = $2
      if ranges.length > 0
        _, range, ranges = ranges.partition /.-./um
        input << range
      end while ranges.length > 0
      singles.scan(/./um).each{|s| input << s}
    end
  end
end


#---------------------------------------------- MAIN --------------------------

options = {}
opts = OptionParser.new do |opts|
  opts.version = '0.0.1'
  opts.banner = BANNER
  opts.on('-c', '--classname NAME',
          "Class/module/function name for generated library code "+
          "(default STATE_TABLE_FILE)") do |v|
    options[:classname] = v
  end
  opts.on('-l', '--language LANGUAGE',
          "Language to generate code for- currently one of [#{LANGUAGES.join(',')}] " +
          "(default #{LANGUAGES.first})") do |v|
    options[:language] = v.underscore.to_sym
  end
  opts.on('-t', '--test-with FILE',
          "Try parsing the specified file after generating the parser "+
          "(default STATE_TABLE_FILE.gmtest if it exists)") do |v|
    options[:test_file] = v
  end
  opts.on('-e', '--[no-]executable',
          "Generate an executable parser (default true)") do |v|
    options[:executable] = v
  end
end


files = opts.parse(ARGV)
if files.size < 1
  $stderr.puts BANNER
  exit 1
end

file_base = files[0].chomp(File.extname(files[0]))
name_base = File.basename(file_base)
options[:executable] ||= true
options[:language]   ||= LANGUAGES.first
options[:classname]  ||= name_base.capitalize + 'Parser'
options[:test_file]  ||= files[0] + '.gmtest'
class_fname = options[:classname].underscore + '.rb'
exe_fname = name_base.underscore

gm = GenMachine.new(files)
gm.build
gm.generate_class(options[:classname], class_fname, options[:language])
if options[:executable]
  gm.generate_executable(exe_fname, options[:language])
end

