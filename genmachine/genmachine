#!/usr/bin/env ruby
require 'pp'
require 'erb'
require 'optparse'

LANGUAGES = [:ruby]
BANNER = "Usage: genmachine [options] STATE_TABLE_FILES"

class String
  def underscore
    self.gsub(/::/, '/').
    gsub(/([A-Z]+)([A-Z][a-z])/,'\1_\2').
    gsub(/([a-z\d])([A-Z])/,'\1_\2').
    gsub(/[^a-zA-Z_]/,'_').
    downcase
  end

  def utf8_chars
    self.unpack("U*")
  end
end

class CharSet
  attr_accessor :kind
  def initialize(kind = :include)
    @kind = kind
    @include_intervals = []
    @include_any = false
  end

  def inspect
    look_for.inspect
  end

  def look_for
    if @include_any
      return @kind==:include ? :any : :none
    elsif @include_intervals.length == 0
      return @kind==:include ? :none : :any
    else
      ivals = @include_intervals.map do |a,b|
        a == b ? a : [a,b]
      end
      return {:kind=>@kind, :ranges=>ivals}
    end
  end

  def +(val) self.send(:<<,val) end
  def <<(val)
    if val.is_a?(String) && val =~ /([^-])-([^-])/
        include_range($1,$2)
    elsif val.is_a?(Range)
      include_range(val.first, val.last)
    elsif val == :any
      @include_any = true
    else include_char(val) end
  end

  def include_char(char) include_range(char,char) end

  def include_range(from, to)
    from = from.utf8_chars[0] if from.is_a?(String)
    to = to.utf8_chars[0] if to.is_a?(String)
    @include_intervals << [from,to].sort
    if @include_intervals.length > 1
      @include_intervals.sort!
      merged = []
      curr_a, curr_b = @include_intervals.shift
      @include_intervals.each_with_index do |ab,i|
        a,b = ab
        if a <= (curr_b+1)
          curr_b = [curr_b,b].max
        else
          merged << [curr_a, curr_b]
          curr_a,curr_b = ab
        end
      end
      merged << [curr_a, curr_b]
      @include_intervals = merged
    end
  end
end

class GenMachine
  def initialize(files)
    @table = []
    #@last_state = nil
    #@first_state = 'nil'
    @files = files
    @libraries = {}
    @executables = {}
    template_base = File.expand_path(File.dirname(__FILE__))+'/templates/'
    LANGUAGES.each do |lang|
      tbase = template_base + lang.to_s + '/'
      @libraries[lang] = ERB.new IO.read(tbase+'library.erb.rb')
      @executables[lang] = ERB.new IO.read(tbase+'executable.erb')
    end
  end

  def build
    c_name = c_args = c_cmds = c_first_state = c_states = nil
    new_fun = false
    @files.each do |fname|
      File.new(fname,'r').each_with_index do |line, line_no|
        line = line.strip
        det = line[0..0]
        if det == '|' or det == ':'
          cols = line.split(det,-1)[1..-1].map{|c| c.strip}
          if det=='|' && cols[0].include?('(')
            new_fun = true
            unless c_name.nil?
              @table << [c_name, c_args, c_cmds, c_first_state, process_states(c_states)]
            end
            parts = cols[0].split('(')
            c_name = parts.shift.underscore
            c_args = parts.join('(').sub(/\)$/,'').split(',')
            c_states = []
            c_cmds = (cols[3]||'').split(';')
            c_first_state = cols[4]
            # TODO: error if cols[1] or cols[2] have anything
          elsif det == ':' && new_fun
            c_args += cols[0].sub(/\)$/,'').split(',')
            c_cmds += (cols[3]||'').split(';')
            c_first_state += (cols[4]||'')
          elsif det == '|'
            new_fun = false
            conditionals, inputs = parse_input(cols[1])
            c_states << {:name  => cols[0],
                         :input => inputs,
                         :cond  => conditionals,
                         :acc   => cols[2],
                         :exprs => (cols[3]||'').split(';'),
                         :next  => cols[4]}
          elsif det == ':' && (c_states.size > 0)
            conditionals, inputs = parse_input(cols[1],c_states[-1][:input])
            c_states[-1][:name] += (cols[0]||'')
            c_states[-1][:input] = inputs
            c_states[-1][:cond] += conditionals
            c_states[-1][:acc]  += cols[2]
            c_states[-1][:exprs]+= (cols[3]||'').split(';')
            c_states[-1][:next] += cols[4]
          end
        end
      end
      unless c_name.nil?
        @table << [c_name, c_args, c_cmds, c_first_state, process_states(c_states)]
      end
    end
    pp @table
  end
=begin
  def build
    @files.each do |fname|
      File.new(fname,'r').each_with_index do |line, line_no|
        line = line.strip
        det = line[0..0]
        if det == '|' or (det == ':' && @last_state)
          cols = line.split(det,-1)[1..-1].map{|c| c.strip}
          conditionals, inputs = parse_input(cols[1])
          row = {
            :input => inputs,
            :cond  => conditionals,
            :acc   => cols[2],
            :exprs => (cols[3]||'').split(';'),
            :next  => '__'+cols[4].underscore}
          if det == '|'
            state = parse_statename(cols[0])
            @table[state] ||= []
            @table[state] << row
            @last_state = state
          elsif det == ':'
            @table[@last_state].last.each do |k,v|
              unless row[k].nil?
                @table[@last_state].last[k] = v.nil? ? row[k] : v + row[k]
              end
            end
          end
        end
      end
    end
    pp @table
  end
=end

  def generate_class(classname, fname, language)
    @classname = classname
    f = File.new(fname, 'w+')
    f.write(@libraries[language].result(binding))
    f.close
  end

  def generate_executable(executablename, language)
    f = File.new(executablename, 'w+')
    f.write(@executables[language].result(binding))
    f.chmod(0755)
    f.close
  end

  private

  def parse_statename(val)
    if val.start_with? '>'
      state = '__'+val[1..-1].strip.underscore
      @first_state ||= state
    else
      state = '__'+val.underscore
    end
    return state
  end

  def aggregates?(states)
    false
  end

  def makes_calls?(states)
    false
  end

  # consolidate same-name states and (eventually) combine / optimize where
  # appropriate.
  def process_states(instates)
    outstates = {}
    instates.each do |inst|
      name = inst.delete(:name)
      outstates[name] ||= []
      outstates[name] << inst
    end
    return outstates
  end

  def parse_input(val,inputs=nil)
    iters = 0
    conds = []
    while val.strip.length > 0 && iters < 100
      case
      when val =~ /--+/um
        val.sub!($&,'')
      when val =~ /\s*\{([^\}]+)\}\s*/um
        conds << $1
        val.sub!($&, '')
      when val =~ /\s*\[\^([^\]]+)\]\s*/um
        inputs ||= CharSet.new(:exclude)
        parse_combine_ranges($1, inputs)
        val.sub!($&, '')
      when val =~ /\s*\[([^\]]+)\]\s*/um
        inputs ||= CharSet.new(:include)
        parse_combine_ranges($1, inputs)
        val.sub!($&, '')
      when val =~ /^\s*\./um
        inputs ||= CharSet.new(:include)
        inputs << :any
        val.sub!($&, '')
      end
      iters += 1
    end
    return conds, inputs
  end

  ESCAPES = {'\t' => "\t", '\n' => "\n",
             '\r' => "\r", '\f' => "\f",
             '\b' => "\b", '\a' => "\a",
             '\e' => "\e", '\s' => " ",
             '\[' => '[',  '\]' => ']'}
  def parse_combine_ranges(raw, input)
    raw.gsub!(/\\[tnrfbaes\[\]]/){|m| ESCAPES[m]}
    if raw =~ /((?:.-.)*)((?:.)*)/um
      ranges = $1
      singles = $2
      if ranges.length > 0
        _, range, ranges = ranges.partition /.-./um
        input << range
      end while ranges.length > 0
      singles.scan(/./um).each{|s| input << s}
    end
  end
end


#---------------------------------------------- MAIN --------------------------

options = {}
opts = OptionParser.new do |opts|
  opts.version = '0.0.1'
  opts.banner = BANNER
  opts.on('-c', '--classname NAME',
          "Class/module/function name for generated library code "+
          "(default STATE_TABLE_FILE)") do |v|
    options[:classname] = v
  end
  opts.on('-l', '--language LANGUAGE',
          "Language to generate code for- currently one of [#{LANGUAGES.join(',')}] " +
          "(default #{LANGUAGES.first})") do |v|
    options[:language] = v.underscore.to_sym
  end
  opts.on('-t', '--test-with FILE',
          "Try parsing the specified file after generating the parser "+
          "(default STATE_TABLE_FILE.gmtest if it exists)") do |v|
    options[:test_file] = v
  end
  opts.on('-e', '--[no-]executable',
          "Generate an executable parser (default true)") do |v|
    options[:executable] = v
  end
end


files = opts.parse(ARGV)
if files.size < 1
  $stderr.puts BANNER
  exit 1
end

file_base = files[0].chomp(File.extname(files[0]))
name_base = File.basename(file_base)
options[:executable] ||= true
options[:language]   ||= LANGUAGES.first
options[:classname]  ||= name_base.capitalize + 'Parser'
options[:test_file]  ||= files[0] + '.gmtest'
class_fname = options[:classname].underscore + '.rb'
exe_fname = name_base.underscore

gm = GenMachine.new(files)
gm.build
gm.generate_class(options[:classname], class_fname, options[:language])
if options[:executable]
  gm.generate_executable(exe_fname, options[:language])
end

