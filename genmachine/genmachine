#!/usr/bin/env ruby
require 'pp'
require 'erb'
require 'optparse'

LANGUAGES = [:ruby]
BANNER = "Usage: genmachine [options] STATE_TABLE_FILES"

class String
  def underscore
    self.gsub(/::/, '/').
    gsub(/([A-Z]+)([A-Z][a-z])/,'\1_\2').
    gsub(/([a-z\d])([A-Z])/,'\1_\2').
    gsub(/[^a-zA-Z_]/,'_').
    downcase
  end
end

class CharSet
  def initialize(start_as = :empty) # Or :full
    # Only combine these lazily so that exclusions can be put in before
    # inclusions
    @start_as = start_as
    @include = []
    @exclude = []
  end

  def to_conditional

  end

  def -(val)

  end

  def +(val)

  end

  def include_char

  end

  def include_range(from, to)
    from = from[0] if from.is_a? String
    to = to[0] if to.is_a? String
    # isolated/island, merge one side, merge the other side
    # ####      ####     - island
    #      ^^^
    # ####      ####     - merge left
    #   ^^^^^^
    # ####      ####     - merge right
    #       ^^^^
    # ####      ####     - merge left and right
    #     ^^^^^^
    # ####      ####     - also merge left and right
    #^^^^^^^^^^^^^^^^^
    #
    merge_right = []
    @include.each_with_index do |ab,i|
      a,b = ab


    end
  end

  def exclude_char(chr)

  end

  def exclude_range(from, to)

  end
end

class GenMachine
  def initialize(files)
    @table = {}
    @last_state = nil
    @first_state = "__initial"
    @files = files
    @libraries = {}
    @executables = {}
    template_base = File.expand_path(File.dirname(__FILE__))+'/templates/'
    LANGUAGES.each do |lang|
      tbase = template_base + lang.to_s + '/'
      @libraries[lang] = ERB.new IO.read(tbase+'library.erb')
      @executables[lang] = ERB.new IO.read(tbase+'executable.erb')
    end
  end

  def build
    @files.each do |fname|
      File.new(fname,'r').each_with_index do |line, line_no|
        line = line.strip
        det = line[0..0]
        if det == '|' or (det == ':' && @last_state)
          cols = line.split(det,-1)[1..-1].map{|c| c.strip}
          pp parse_input(cols[1])
          row = {
            :input => parse_input(cols[1]),
            :acc   => cols[2],
            :exprs => (cols[3]||'').split(';'),
            :next  => '__'+cols[4].underscore}
          if det == '|'
            state = parse_statename(cols[0])
            @table[state] ||= []
            @table[state] << row
            @last_state = state
          elsif det == ':'
            @table[@last_state].last.each do |k,v|
              unless v.is_a? Hash
                @table[@last_state].last[k] = v.nil? ? row[k] : v + row[k]
              end
            end
          end
        end
      end
    end
    pp @table
  end

  def generate_class(classname, fname, language)
    @classname = classname
    f = File.new(fname, 'w+')
    f.write(@libraries[language].result(binding))
    f.close
  end

  def generate_executable(executablename, language)
    f = File.new(executablename, 'w+')
    f.write(@executables[language].result(binding))
    f.chmod(0755)
    f.close
  end

  private

  def parse_statename(val)
    if val.start_with? '>'
      state = '__'+val[1..-1].strip.underscore
      @first_state ||= state
    else
      state = '__'+val.underscore
    end
    return state
  end

  def parse_input(val, current=nil)
    current ||= {:conditionals=>[], :ranges=>[], :notranges=>[]}
    iters = 0
    while val.strip.length > 0 && iters < 100
      if val =~ /\s*\{([^\}])\}\s*/u
        current[:conditional] << $1
        val.sub!($&, '')
      end
      if val =~ /\s*\[\^([^\]]+)\]\s*/u
        current[:notranges] = parse_combine_ranges($1, current[:notranges])
        val.sub!($&, '')
      end
      if val =~ /\s*\[([^\]]+)\]\s*/u
        current[:ranges] = parse_combine_ranges($1, current[:ranges])
        val.sub!($&, '')
      end
      if val =~ /^\s*./u
        current[:ranges] = [:any]
        val.sub!($&, '')
      end
      iters += 1
    end
    return current
  end

  ESCAPES = {'\t' => "\t", '\n' => "\n",
             '\r' => "\r", '\f' => "\f",
             '\b' => "\b", '\a' => "\a",
             '\e' => "\e", '\s' => " "}
  # [any | [\dlow,\dhigh] | \d]
  # parse control characters / metacharacters first
  def parse_combine_ranges(raw, processed)
    raw.gsub!(/\\[tnrfbaes]/){|m| ESCAPES[m]}
    if raw =~ /((?:.-.)*)((?:.)*)/
      ranges = $1
      if ranges.length > 0
        _, range, ranges = ranges.partition /.-./
        pp range
      end while ranges.length > 0
    end
  end
end


#---------------------------------------------- MAIN --------------------------

options = {}
opts = OptionParser.new do |opts|
  opts.version = '0.0.1'
  opts.banner = BANNER
  opts.on('-c', '--classname NAME',
          "Class/module/function name for generated library code "+
          "(default STATE_TABLE_FILE)") do |v|
    options[:classname] = v
  end
  opts.on('-l', '--language LANGUAGE',
          "Language to generate code for- currently one of [#{LANGUAGES.join(',')}] " +
          "(default #{LANGUAGES.first})") do |v|
    options[:language] = v.underscore.to_sym
  end
  opts.on('-t', '--test-with FILE',
          "Try parsing the specified file after generating the parser "+
          "(default STATE_TABLE_FILE.gmtest if it exists)") do |v|
    options[:test_file] = v
  end
  opts.on('-e', '--[no-]executable',
          "Generate an executable parser (default true)") do |v|
    options[:executable] = v
  end
end


files = opts.parse(ARGV)
if files.size < 1
  $stderr.puts BANNER
  exit 1
end

file_base = files[0].chomp(File.extname(files[0]))
name_base = File.basename(file_base)
options[:executable] ||= true
options[:language]   ||= LANGUAGES.first
options[:classname]  ||= name_base.capitalize + 'Parser'
options[:test_file]  ||= files[0] + '.gmtest'
class_fname = options[:classname].underscore + '.rb'
exe_fname = name_base.underscore

gm = GenMachine.new(files)
gm.build
gm.generate_class(options[:classname], class_fname, options[:language])
if options[:executable]
  gm.generate_executable(exe_fname, options[:language])
end

